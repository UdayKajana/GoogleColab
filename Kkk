import io
from google.cloud import pubsub_v1
import pandas as pd
import json
import avro.schema
from avro.io import DatumReader, BinaryDecoder
from io import BytesIO
import traceback

# Define the Avro schema as a JSON string
schema_json = json.dumps({
    "type": "record",
    "name": "ChurnData",
    "fields": [
        {"name": "ont_activation_date", "type": ["null", "string"]},
        {"name": "data_circuit_id", "type": ["null", "string"]},
        {"name": "circuit_id", "type": ["null", "string"]},
        {"name": "video_circuit_id", "type": ["null", "string"]},
        {"name": "service_type", "type": ["null", "string"]},
        {"name": "address_id", "type": ["null", "string"]},
        {"name": "vision_account_id", "type": ["null", "string"]},
        {"name": "vision_customer_id", "type": ["null", "string"]},
        {"name": "address_type", "type": ["null", "string"]},
        {"name": "line_of_business", "type": ["null", "string"]}
    ]
})

def process_avro_message(message):
    try:
        # Print raw message data for debugging
        print("Raw message data:", type(message.data))
        
        # Parse the Avro schema from JSON string
        parsed_schema = avro.schema.parse(schema_json)
        
        # Create a DatumReader with the schema
        reader = DatumReader(parsed_schema)
        
        # Ensure we're working with bytes
        if not isinstance(message.data, bytes):
            print(f"Unexpected message data type: {type(message.data)}")
            message.nack()
            return None
        
        # Create BytesIO and BinaryDecoder
        bytes_reader = BytesIO(message.data)
        decoder = BinaryDecoder(bytes_reader)
        
        rows = []
        try:
            # Attempt to read records
            while True:
                try:
                    # Read a record using the schema
                    record = reader.read(decoder)
                    
                    # Process the record
                    processed_record = {}
                    for field in parsed_schema.fields:
                        field_name = field.name
                        value = record.get(field_name)
                        
                        # Handle various value types
                        if value is None:
                            processed_record[field_name] = None
                        elif isinstance(value, (dict, list)):
                            processed_record[field_name] = str(value)
                        else:
                            processed_record[field_name] = value
                    
                    rows.append(processed_record)
                
                except EOFError:
                    # Reached end of records
                    break
                except Exception as record_error:
                    print(f"Error reading individual record: {record_error}")
                    print(traceback.format_exc())
                    break
            
            # Convert to DataFrame and save
            if rows:
                df = pd.DataFrame(rows)
                csv_filename = f'pubsub_data_{pd.Timestamp.now().strftime("%Y%m%d_%H%M%S")}.csv'
                df.to_csv(csv_filename, index=False)
                print(f"Saved {len(df)} records to {csv_filename}")
                message.ack()
                return df
            else:
                print("No records processed from the message")
                message.ack()
                return None
        
        except Exception as decode_error:
            print(f"Decoding error: {decode_error}")
            print(traceback.format_exc())
            message.nack()
            return None
    
    except Exception as e:
        print(f"Overall processing error: {e}")
        print(traceback.format_exc())
        message.nack()
        return None

# Pub/Sub configuration
project_id = "vz-it-np-gudv-dev-vzntdo-0"
subscription_id = "wireline_churn_test_topic-sub"

# Create Pub/Sub subscriber
subscriber = pubsub_v1.SubscriberClient()
subscription_path = f"projects/{project_id}/subscriptions/{subscription_id}"

# Subscribe and process messages
streaming_pull_future = subscriber.subscribe(subscription_path, callback=process_avro_message)

print("Listening for messages on subscription:", subscription_path)

with subscriber:
    try:
        streaming_pull_future.result(timeout=300)  # 5-minute timeout
    except TimeoutError:
        streaming_pull_future.cancel()
        streaming_pull_future.result()
