import json
import avro.io as avro_io
import avro.schema
from google.cloud import pubsub_v1
from concurrent.futures import TimeoutError
import io
import logging

def decode_avro(avro_bytes: bytes) -> dict:
    """
    Decode Avro binary data back into a Python dictionary.
    """
    schema = """{"namespace": "com.vz.vznet",
                "type": "record",
                "name": "VznetDefault",
                "doc": "Default schema for events in transit",
                "fields": [
                    {"name": "timestamp", "type": "long"},
                    {"name": "host", "type": "string"},
                    {"name": "src",  "type": "string" },
                    {"name": "_event_ingress_ts", "type": "long"},
                    {"name": "_event_origin", "type": "string"},
                    {"name": "_event_tags", "type": "array", "items": "string"},
                    {"name": "_event_route", "type": "string"},
                    {"name": "_event_metrics", "type": ["null", "bytes"], "default": null},
                    {"name": "rawdata", "type": "bytes"}
                ]
            }"""
    
    parsed_schema = avro.schema.parse(schema)
    bytes_reader = io.BytesIO(avro_bytes)
    decoder = avro_io.BinaryDecoder(bytes_reader)
    datum_reader = avro_io.DatumReader(parsed_schema)
    
    result = datum_reader.read(decoder)
    
    # Convert rawdata bytes back to dict
    if result.get('rawdata'):
        result['rawdata'] = json.loads(result['rawdata'].decode('utf-8'))
        
    return result

def receive_messages(project_id: str, subscription_id: str, timeout: float = None):
    """
    Receives messages from a Pub/Sub subscription and decodes the Avro payload.
    """
    subscriber = pubsub_v1.SubscriberClient()
    subscription_path = subscriber.subscription_path(project_id, subscription_id)
    
    def callback(message: pubsub_v1.subscriber.message.Message) -> None:
        try:
            decoded_data = decode_avro(message.data)
            print(f"Received message:")
            print(f"Data: {json.dumps(decoded_data, indent=2)}")
            # Acknowledge the message
            message.ack()
            
        except Exception as e:
            print(f"Error processing message: {e}")
            # Nack the message in case of processing error
            message.nack()

    streaming_pull_future = subscriber.subscribe(subscription_path, callback=callback)
    print(f"Listening for messages on {subscription_path}")

    try:
        streaming_pull_future.result(timeout=timeout)
    except TimeoutError:
        streaming_pull_future.cancel()  # Trigger the shutdown
        streaming_pull_future.result()  # Block until the shutdown is complete
    finally:
        subscriber.close()

if __name__ == "__main__":
    # Example usage
    PROJECT_ID = "vz-it-np-gudv-dev-vzntdo-0"
    SUBSCRIPTION_ID = "wireline_churn_test_sub"  # Replace with your subscription ID
    
    try:
        # Start receiving messages
        receive_messages(PROJECT_ID, SUBSCRIPTION_ID, timeout=30)  # Listen for 30 seconds
    except KeyboardInterrupt:
        print("Stopping message reception...")
